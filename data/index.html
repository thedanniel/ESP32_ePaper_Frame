<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Porta-Retrato Digital</title>
    <style>
      body {
        background: #f2f2f2;
        font-family: Arial, Helvetica, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
      }

      h1 {
        color: #333;
      }

      input[type="file"] {
        display: none;
      }

      .red-button {
        width: 150px;
        /* Slightly wider for better text fit */
        background-color: #cc0000;
        color: white;
        text-align: center;
        display: inline-block;
        font-size: 16px;
        padding: 14px 0px;
        margin: 8px;
        /* Adjusted margin for spacing */
        border-radius: 8px;
        box-shadow: 0 8px 16px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
        cursor: pointer;
        border: 2px solid #800000;
        transition: all 0.3s ease;
        /* Smooth transition for hover effects */
      }

      .red-button:hover {
        box-shadow: none;
        background-color: #e60000;
      }

      .pad-button {
        width: 50px;
        background-color: #cc0000;
        color: white;
        text-align: center;
        display: inline-block;
        font-size: 18px;
        /* Larger font for arrows */
        padding: 14px 0px;
        margin: 4px;
        /* Adjusted margin */
        border-radius: 8px;
        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.1), 0 3px 10px 0 rgba(0, 0, 0, 0.09);
        cursor: pointer;
        border: 2px solid #800000;
        transition: all 0.3s ease;
      }

      .pad-button:hover {
        box-shadow: none;
        background-color: #e60000;
      }

      th,
      td {
        padding: 10px 4px;
        text-align: left;
      }

      .container {
        max-width: 900px;
        /* Increased max-width for better layout */
        width: 100%;
        margin: 0 auto;
        text-align: center;
      }

      .canvas-container {
        width: 100%;
        border: 3px solid black;
        border-radius: 5px;
        background: white;
        margin-top: 16px;
        overflow: hidden;
        /* Ensures content doesn't spill out */
      }

      canvas {
        width: 100%;
        display: block;
        /* Remove extra space below canvas */
      }

      .controls-section {
        margin-top: 25px;
        padding: 20px;
        background-color: #fff;
        border-radius: 10px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      .button-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        /* Responsive columns */
        gap: 10px;
        /* Space between buttons */
        margin-bottom: 20px;
        justify-items: center;
        /* Center buttons within their grid cells */
      }

      .dpad-container {
        display: grid;
        grid-template-columns: 50px 50px 50px;
        grid-template-rows: 50px 50px 50px;
        gap: 5px;
        justify-content: center;
        align-items: center;
        margin: 20px 0;
      }

      .dpad-up {
        grid-column: 2 / 3;
        grid-row: 1 / 2;
      }

      .dpad-left {
        grid-column: 1 / 2;
        grid-row: 2 / 3;
      }

      .dpad-right {
        grid-column: 3 / 4;
        grid-row: 2 / 3;
      }

      .dpad-down {
        grid-column: 2 / 3;
        grid-row: 3 / 4;
      }

      .sliders-group,
      .dithering-group {
        display: flex;
        flex-direction: column;
        gap: 15px;
        /* Space between slider items */
        margin-top: 20px;
        padding-top: 15px;
        border-top: 1px solid #eee;
        /* Separator for sliders */
      }

      .slider-item,
      .dithering-item {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      .slider-item label,
      .dithering-item label {
        flex-shrink: 0;
        width: 80px;
        /* Align labels */
        text-align: right;
      }

      .slider-item input[type="range"] {
        flex-grow: 1;
        max-width: 300px;
        -webkit-appearance: none;
        height: 8px;
        background: #ddd;
        border-radius: 5px;
        outline: none;
        opacity: 0.7;
        transition: opacity .2s;
      }

      .slider-item input[type="range"]:hover {
        opacity: 1;
      }

      .slider-item input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #cc0000;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .slider-item input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #cc0000;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .slider-item span {
        width: 40px;
        /* Fixed width for value display */
        text-align: left;
      }

      .send-button {
        width: calc(100% - 16px);
        /* Full width minus margins */
        margin: 20px auto 5px;
        /* Adjust margin */
        padding: 16px 0;
        /* Slightly larger padding */
        font-size: 18px;
      }

      /* Custom Modal Styles */
      #customModal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        /* Darker overlay */
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      #customModal>div {
        background: #fff;
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        max-width: 400px;
        width: 90%;
      }

      #customModal p {
        margin-bottom: 20px;
        font-size: 1.1em;
        color: #333;
      }

      #customModal button {
        padding: 10px 20px;
        margin: 0 10px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1em;
        transition: background-color 0.3s ease;
      }

      #customModal button:first-of-type {
        background-color: #007bff;
        color: white;
      }

      #customModal button:first-of-type:hover {
        background-color: #0056b3;
      }

      #customModal button:last-of-type {
        background-color: #dc3545;
        color: white;
      }

      #customModal button:last-of-type:hover {
        background-color: #c82333;
      }

      /* New styles for radio buttons */
      .dithering-options {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        /* Align radio buttons to the start */
        gap: 8px;
        /* Space between radio buttons */
        margin-left: 90px;
        /* Adjust to align with the "Dithering" label */
      }

      .dithering-options label {
        display: flex;
        align-items: center;
        gap: 5px;
        cursor: pointer;
        font-weight: normal;
        /* Override bold from dithering-item label */
        width: auto;
        /* Allow label to size naturally */
        text-align: left;
      }

      .dithering-options input[type="radio"] {
        margin: 0;
        flex-shrink: 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Porta-Retrato Digital</h1>
      <label class="red-button">
        <input type="file" id="inputFile" />Carregar imagem </label>
      <div style="width: 100%; display: none;">
        <canvas width="800" height="480" id="originalCanvas"></canvas>
      </div>
      <div class="canvas-container">
        <canvas width="800" height="480" id="editedCanvas"></canvas>
      </div>
      <div class="controls-section">
        <div class="button-grid">
          <button class="red-button" onclick="stretchToFit()">Esticar para caber</button>
          <button class="red-button" onclick="zoomImage(1.05)">Aumentar</button>
          <button class="red-button" onclick="zoomImage(0.95)">Diminuir</button>
          <button class="red-button" onclick="rotateImage(-5)">âŸ² Girar para a esquerda</button>
          <button class="red-button" onclick="rotateImage(5)">âŸ³ Girar para a direita</button>
          <button class="red-button" onclick="toggleMirror()">ðŸªž Espelhar</button>
          <button class="red-button" onclick="resetImage()">ðŸ”„ Resetar</button>
        </div>
        <div class="dpad-container">
          <button class="pad-button dpad-up" onclick="moveImage(0, -5)">â¬†</button>
          <button class="pad-button dpad-left" onclick="moveImage(-5, 0)">â¬…</button>
          <button class="pad-button dpad-right" onclick="moveImage(5, 0)">âž¡</button>
          <button class="pad-button dpad-down" onclick="moveImage(0, 5)">â¬‡</button>
        </div>
        <div class="sliders-group">
          <div class="slider-item">
            <label for="contrastSlider">
              <strong>Contraste:</strong>
            </label>
            <input type="range" id="contrastSlider" min="-100" max="100" value="0" step="0.1" />
            <span id="contrastValue">0</span>
          </div>
          <div class="slider-item">
            <label for="brightnessSlider">
              <strong>Brilho:</strong>
            </label>
            <input type="range" id="brightnessSlider" min="-100" max="100" value="0" step="0.1" />
            <span id="brightnessValue">0</span>
          </div>
          <div class="slider-item">
            <label for="gammaSlider">
              <strong>Gamma:</strong>
            </label>
            <input type="range" id="gammaSlider" min="0.1" max="5.0" value="1.0" step="0.1" />
            <span id="gammaValue">1.0</span>
          </div>
        </div>
        <div class="dithering-group">
          <div class="dithering-item">
            <label>
              <strong>Dithering:</strong>
            </label>
            <div class="dithering-options">
              <label>
                <input type="radio" name="ditheringAlgorithm" value="none" checked onchange="applyFilters()"> Nenhum </label>
              <label>
                <input type="radio" name="ditheringAlgorithm" value="floyd-steinberg" onchange="applyFilters()"> Floyd-Steinberg (7 Cores) </label>
              <label>
                <input type="radio" name="ditheringAlgorithm" value="floyd-steinberg-bw" onchange="applyFilters()"> Floyd-Steinberg (P&B) </label>
              <label>
                <input type="radio" name="ditheringAlgorithm" value="ordered-bayer" onchange="applyFilters()"> Ordenado (Bayer) </label>
              <label>
                <input type="radio" name="ditheringAlgorithm" value="stucki" onchange="applyFilters()"> Stucki </label>
            </div>
          </div>
        </div>
        <button onclick="uploadImage()" class="red-button send-button">Enviar imagem para porta-retrato</button>
      </div>
    </div>
    <script>
      let currentScale = 1.0;
      let originalImage = null;
      let currentRotation = 0; // in degrees
      let offsetX = 0;
      let offsetY = 0;
      const input = document.getElementById('inputFile');
      input.addEventListener('change', handleFiles);
      // Map colors to their 7-bit indices
      const COLOR_MAP = {
        "0,0,0": 0, // Black
        "255,255,255": 1, // White
        "0,255,0": 2, // Green
        "0,0,255": 3, // Blue
        "255,0,0": 4, // Red
        "255,255,0": 5, // Yellow
        "255,165,0": 6 // Orange
      };

      function rbg2bit(r, g, b) {
        const key = `${r},${g},${b}`;
        return COLOR_MAP[key] !== undefined ? COLOR_MAP[key] : 0; // Default to black if undefined
      }
      var PALETTE = [
        [0, 0, 0], // Black
        [255, 255, 255], // White
        [0, 255, 0], // Green
        [0, 0, 255], // Blue
        [255, 0, 0], // Red
        [255, 255, 0], // Yellow
        [255, 165, 0] // Orange
      ];

      function find_closest_palette_color(r, g, b, palette = PALETTE) {
        let min_dist = Infinity;
        let closest_color = [0, 0, 0];
        for (let color of palette) {
          let dist = Math.sqrt(Math.pow(r - color[0], 2) + Math.pow(g - color[1], 2) + Math.pow(b - color[2], 2));
          if (dist < min_dist) {
            min_dist = dist;
            closest_color = color;
          }
        }
        return closest_color;
      }

      function handleFiles(e) {
        const file = e.target.files[0];
        if (!file) return;
        const img = new Image();
        img.onload = function() {
          originalImage = img; // set global once loaded
          currentScale = 1.0;
          currentRotation = 0;
          offsetX = 0;
          offsetY = 0;
          resetSliders(); // Reset sliders when a new image is loaded
          drawImage(originalImage, currentScale);
        };
        img.src = URL.createObjectURL(file); // set src AFTER onload handler
      }

      function drawImage(img, scale) {
        const ctxOrigin = document.getElementById('originalCanvas').getContext('2d');
        const ctxEdited = document.getElementById('editedCanvas').getContext('2d');
        const canvasWidth = 800;
        const canvasHeight = 480;
        ctxOrigin.save();
        ctxEdited.save();
        ctxOrigin.setTransform(1, 0, 0, 1, 0, 0); // reset transform
        ctxEdited.setTransform(1, 0, 0, 1, 0, 0);
        ctxOrigin.clearRect(0, 0, canvasWidth, canvasHeight);
        ctxEdited.clearRect(0, 0, canvasWidth, canvasHeight);
        // Fill white background on edited canvas BEFORE clearing
        ctxEdited.fillStyle = "white";
        ctxEdited.fillRect(0, 0, canvasWidth, canvasHeight);
        ctxOrigin.translate(canvasWidth / 2 + offsetX, canvasHeight / 2 + offsetY);
        ctxEdited.translate(canvasWidth / 2 + offsetX, canvasHeight / 2 + offsetY);
        const radians = currentRotation * Math.PI / 180;
        ctxOrigin.rotate(radians);
        ctxEdited.rotate(radians);
        if (isMirrored) {
          ctxOrigin.scale(-1, 1);
          ctxEdited.scale(-1, 1);
        }
        const scaledWidth = img.width * scale;
        const scaledHeight = img.height * scale;
        ctxOrigin.drawImage(img, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
        ctxEdited.drawImage(img, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
        ctxOrigin.restore();
        ctxEdited.restore();
        // Apply filters immediately after drawing the image
        applyFilters();
      }

      function zoomImage(factor) {
        if (!originalImage) {
          alert("Por favor, envie uma imagem primeiro!");
          return;
        }
        currentScale *= factor;
        drawImage(originalImage, currentScale);
      }

      function uploadImage() {
        if (!originalImage) {
          showCustomPopup();
          return;
        }
        console.log("uploadImage");
        websocket = new WebSocket("ws://" + location.hostname + "/test");
        websocket.onopen = function(evt) {
          onOpen(evt)
        };
        websocket.onclose = function(evt) {
          onClose(evt)
        };
        websocket.onmessage = function(evt) {
          onMessage(evt)
        };
        websocket.onerror = function(evt) {
          onError(evt)
        };
      }

      function sendImage() {
        const ctx = document.getElementById('editedCanvas').getContext('2d');
        const imgData = ctx.getImageData(0, 0, 800, 480);
        const d = imgData.data;
        const pixDataArray = new Array((800 * 480) / 2); // 1 byte per 2 pixels
        let j = 0;
        for (let i = 0; i < d.length; i += 8) { // Process two pixels at a time (8 bytes per two pixels)
          const pix0 = rbg2bit(d[i], d[i + 1], d[i + 2]); // Pixel 1
          const pix1 = rbg2bit(d[i + 4], d[i + 5], d[i + 6]); // Pixel 2
          const pixByte = (pix0 << 4) | pix1; // Combine into a single byte
          pixDataArray[j++] = pixByte;
        }
        const bytesArray = new Uint8Array(pixDataArray);
        websocket.send(bytesArray.buffer); // Send the packed data
        console.log("SENT");
        websocket.close();
      }

      function onError(evt) {
        console.log("ERROR:");
        console.log(evt.data); //undefined
      }

      function addToPixel(pixels, pos, quant_error, fraction) {
        if (pos >= 0 && pos < pixels.length) {
          for (let i = 0; i < 3; i++) {
            pixels[pos + i] += quant_error[i] * fraction;
            pixels[pos + i] = Math.min(255, Math.max(0, pixels[pos + i])); // Clamp values
          }
        }
      }

      function redrawToEditedCanvas() {
        const ctxEdited = document.getElementById('editedCanvas').getContext('2d');
        const canvasWidth = 800;
        const canvasHeight = 480;
        ctxEdited.save();
        ctxEdited.setTransform(1, 0, 0, 1, 0, 0); // reset
        ctxEdited.clearRect(0, 0, canvasWidth, canvasHeight);
        ctxEdited.fillStyle = "white";
        ctxEdited.fillRect(0, 0, canvasWidth, canvasHeight);
        ctxEdited.translate(canvasWidth / 2 + offsetX, canvasHeight / 2 + offsetY);
        const radians = currentRotation * Math.PI / 180;
        ctxEdited.rotate(radians);
        if (isMirrored) {
          ctxEdited.scale(-1, 1);
        }
        const scaledWidth = originalImage.width * currentScale;
        const scaledHeight = originalImage.height * currentScale;
        ctxEdited.drawImage(originalImage, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
        ctxEdited.restore();
      }
      // New dither function incorporating all types
      function applyDithering(pixels, width, height, algorithm, palette) {
        const R = 0,
          G = 1,
          B = 2,
          A = 3;
        if (algorithm === 'floyd-steinberg' || algorithm === 'floyd-steinberg-bw') {
          const targetPalette = algorithm === 'floyd-steinberg-bw' ? [
            [0, 0, 0],
            [255, 255, 255]
          ] : palette;
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const pos = (y * width + x) * 4;
              const oldR = pixels[pos + R];
              const oldG = pixels[pos + G];
              const oldB = pixels[pos + B];
              const newRGB = find_closest_palette_color(oldR, oldG, oldB, targetPalette);
              pixels[pos + R] = newRGB[0];
              pixels[pos + G] = newRGB[1];
              pixels[pos + B] = newRGB[2];
              pixels[pos + A] = 255;
              const quant_error = [
                oldR - newRGB[0],
                oldG - newRGB[1],
                oldB - newRGB[2]
              ];
              addToPixel(pixels, pos + 4, quant_error, 7.0 / 16);
              addToPixel(pixels, pos - 4 + (width * 4), quant_error, 3.0 / 16);
              addToPixel(pixels, pos + (width * 4), quant_error, 5.0 / 16);
              addToPixel(pixels, pos + 4 + (width * 4), quant_error, 1.0 / 16);
            }
          }
        } else if (algorithm === 'ordered-bayer') {
          const bayerMatrix = [
            [15, 135, 45, 165],
            [195, 75, 225, 105],
            [60, 180, 30, 150],
            [240, 120, 210, 90]
          ];
          const matrixSize = bayerMatrix.length;
          const targetPalette = palette; // Use full palette for ordered dither (can be modified for BW)
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const pos = (y * width + x) * 4;
              const r = pixels[pos + R];
              const g = pixels[pos + G];
              const b = pixels[pos + B];
              const threshold = bayerMatrix[y % matrixSize][x % matrixSize];
              // For ordered dithering, we compare each channel with the threshold
              // and then find the closest color. This is a simplification;
              // a more accurate approach involves perturbing the original color
              // based on the threshold before finding the closest palette color.
              // For a simple 7-color e-ink, we'll perturb the intensity.
              const avg = (r + g + b) / 3;
              const newR = clamp(r + (avg - threshold) / 255 * 100); // Simple perturbation
              const newG = clamp(g + (avg - threshold) / 255 * 100);
              const newB = clamp(b + (avg - threshold) / 255 * 100);
              const newRGB = find_closest_palette_color(newR, newG, newB, targetPalette);
              pixels[pos + R] = newRGB[0];
              pixels[pos + G] = newRGB[1];
              pixels[pos + B] = newRGB[2];
              pixels[pos + A] = 255;
            }
          }
        } else if (algorithm === 'stucki') {
          const targetPalette = palette; // Use full palette for Stucki
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const pos = (y * width + x) * 4;
              const oldR = pixels[pos + R];
              const oldG = pixels[pos + G];
              const oldB = pixels[pos + B];
              const newRGB = find_closest_palette_color(oldR, oldG, oldB, targetPalette);
              pixels[pos + R] = newRGB[0];
              pixels[pos + G] = newRGB[1];
              pixels[pos + B] = newRGB[2];
              pixels[pos + A] = 255;
              const quant_error = [
                oldR - newRGB[0],
                oldG - newRGB[1],
                oldB - newRGB[2]
              ];
              // Stucki error diffusion matrix
              // [X  X  X  8/42 4/42]
              // [2/42 4/42 8/42 4/42 2/42]
              // [1/42 2/42 4/42 2/42 1/42]
              addToPixel(pixels, pos + 4, quant_error, 8 / 42); // (x+1, y)
              addToPixel(pixels, pos + 8, quant_error, 4 / 42); // (x+2, y)
              addToPixel(pixels, pos - 8 + (width * 4), quant_error, 2 / 42); // (x-2, y+1)
              addToPixel(pixels, pos - 4 + (width * 4), quant_error, 4 / 42); // (x-1, y+1)
              addToPixel(pixels, pos + (width * 4), quant_error, 8 / 42); // (x, y+1)
              addToPixel(pixels, pos + 4 + (width * 4), quant_error, 4 / 42); // (x+1, y+1)
              addToPixel(pixels, pos + 8 + (width * 4), quant_error, 2 / 42); // (x+2, y+1)
              addToPixel(pixels, pos - 8 + (2 * width * 4), quant_error, 1 / 42); // (x-2, y+2)
              addToPixel(pixels, pos - 4 + (2 * width * 4), quant_error, 2 / 42); // (x-1, y+2)
              addToPixel(pixels, pos + (2 * width * 4), quant_error, 4 / 42); // (x, y+2)
              addToPixel(pixels, pos + 4 + (2 * width * 4), quant_error, 2 / 42); // (x+1, y+2)
              addToPixel(pixels, pos + 8 + (2 * width * 4), quant_error, 1 / 42); // (x+2, y+2)
            }
          }
        } else if (algorithm === 'none') {
          // No dithering, just quantize to palette
          for (let i = 0; i < pixels.length; i += 4) {
            const r = pixels[i];
            const g = pixels[i + 1];
            const b = pixels[i + 2];
            const newColor = find_closest_palette_color(r, g, b, palette);
            pixels[i] = newColor[0];
            pixels[i + 1] = newColor[1];
            pixels[i + 2] = newColor[2];
            pixels[i + 3] = 255;
          }
        }
      }

      function applyFilters() {
        if (!originalImage) return;
        redrawToEditedCanvas(); // Start with the fresh, un-dithered image
        const ctx = document.getElementById('editedCanvas').getContext('2d');
        const imgData = ctx.getImageData(0, 0, 800, 480);
        const pixels = imgData.data;
        applyContrast(pixels, parseFloat(contrastSlider.value));
        applyBrightness(pixels, parseFloat(brightnessSlider.value));
        applyGamma(pixels, parseFloat(gammaSlider.value)); // Apply gamma
        // Get the selected dithering algorithm from the radio buttons
        const selectedDither = document.querySelector('input[name="ditheringAlgorithm"]:checked');
        const ditheringAlgorithm = selectedDither ? selectedDither.value : 'none';
        applyDithering(pixels, 800, 480, ditheringAlgorithm, PALETTE); // Apply selected dithering
        ctx.putImageData(imgData, 0, 0);
      }

      function applyContrast(pixels, contrast) {
        const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
        for (let i = 0; i < pixels.length; i += 4) {
          pixels[i] = clamp(factor * (pixels[i] - 128) + 128); // Red
          pixels[i + 1] = clamp(factor * (pixels[i + 1] - 128) + 128); // Green
          pixels[i + 2] = clamp(factor * (pixels[i + 2] - 128) + 128); // Blue
        }
      }

      function clamp(value) {
        return Math.max(0, Math.min(255, value));
      }
      var contrastValue = document.getElementById('contrastValue');
      var contrastSlider = document.getElementById('contrastSlider');
      contrastSlider.addEventListener('input', () => {
        contrastValue.textContent = contrastSlider.value;
        applyFilters();
      });

      function applyBrightness(pixels, brightness) {
        for (let i = 0; i < pixels.length; i += 4) {
          pixels[i] = clamp(pixels[i] + brightness); // Red
          pixels[i + 1] = clamp(pixels[i + 1] + brightness); // Green
          pixels[i + 2] = clamp(pixels[i + 2] + brightness); // Blue
        }
      }
      var brightnessValue = document.getElementById('brightnessValue');
      var brightnessSlider = document.getElementById('brightnessSlider');
      brightnessSlider.addEventListener('input', () => {
        brightnessValue.textContent = brightnessSlider.value;
        applyFilters();
      });

      function applyGamma(pixels, gamma) {
        const invGamma = 1 / gamma;
        for (let i = 0; i < pixels.length; i += 4) {
          pixels[i] = clamp(255 * Math.pow(pixels[i] / 255, invGamma)); // Red
          pixels[i + 1] = clamp(255 * Math.pow(pixels[i + 1] / 255, invGamma)); // Green
          pixels[i + 2] = clamp(255 * Math.pow(pixels[i + 2] / 255, invGamma)); // Blue
        }
      }
      var gammaValue = document.getElementById('gammaValue');
      var gammaSlider = document.getElementById('gammaSlider');
      gammaSlider.addEventListener('input', () => {
        gammaValue.textContent = gammaSlider.value;
        applyFilters();
      });

      function stretchToFit() {
        if (!originalImage) {
          alert("Por favor, envie uma imagem primeiro!");
          return;
        }
        const canvas = document.getElementById('editedCanvas');
        const ctx = canvas.getContext('2d');
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0); // reset
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        const rotated = (Math.abs(currentRotation) % 180 === 90);
        const imgWidth = rotated ? originalImage.height : originalImage.width;
        const imgHeight = rotated ? originalImage.width : originalImage.height;
        const scaleWidth = canvasWidth / imgWidth;
        const scaleHeight = canvasHeight / imgHeight;
        const scale = Math.min(scaleWidth, scaleHeight);
        const newWidth = originalImage.width * scale;
        const newHeight = originalImage.height * scale;
        ctx.translate(canvasWidth / 2, canvasHeight / 2);
        const radians = currentRotation * Math.PI / 180;
        ctx.rotate(radians);
        ctx.drawImage(originalImage, -newWidth / 2, -newHeight / 2, newWidth, newHeight);
        ctx.restore();
        currentScale = scale;
        offsetX = 0;
        offsetY = 0;
        applyFilters(); // Apply filters after stretching
      }

      function rotateImage(degrees) {
        if (!originalImage) {
          alert("Por favor, envie uma imagem primeiro!");
          return;
        }
        currentRotation = (currentRotation + degrees) % 360;
        drawImage(originalImage, currentScale);
      }

      function moveImage(dx, dy) {
        if (!originalImage) {
          alert("Por favor, envie uma imagem primeiro!");
          return;
        }
        offsetX += dx;
        offsetY += dy;
        drawImage(originalImage, currentScale);
      }
      let isMirrored = false;

      function toggleMirror() {
        if (!originalImage) {
          alert("Por favor, envie uma imagem primeiro!");
          return;
        }
        isMirrored = !isMirrored;
        drawImage(originalImage, currentScale);
      }

      function resetImage() {
        if (!originalImage) {
          alert("Por favor, envie uma imagem primeiro!");
          return;
        }
        currentScale = 1.0;
        currentRotation = 0;
        offsetX = 0;
        offsetY = 0;
        resetSliders(); // Reset sliders to default values
        applyFilters(); // Apply filters after resetting
      }

      function resetSliders() {
        contrastSlider.value = 0;
        contrastValue.textContent = '0';
        brightnessSlider.value = 0;
        brightnessValue.textContent = '0';
        gammaSlider.value = 1.0;
        gammaValue.textContent = '1.0';
      }

      function initWebSocket() {}

      function onOpen(evt) {
        console.log("CONNECTED");
        websocket.send("Can I send data?");
      }

      function onClose(evt) {
        console.log("DISCONNECTED");
      }

      function onMessage(evt) {
        console.log("RESPONSE:");
        console.log(evt.data);
        if (evt.data == "OK") {
          sendImage();
        } else if (evt.data == "BUSY") {
          alert("O display estÃ¡ em uso - Aguarde para enviar nova imagem");
          websocket.close();
        } else {
          websocket.close();
        }
      }

      function showCustomPopup() {
        document.getElementById('customModal').style.display = 'flex';
      }

      function closeCustomPopup() {
        document.getElementById('customModal').style.display = 'none';
      }

      function onModalOk() {
        closeCustomPopup();
      }

      function onModalClear() {
        closeCustomPopup();
        console.log("Clearing screen");
        const ctx = document.getElementById('editedCanvas').getContext('2d');
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, 800, 480);
        websocket = new WebSocket("ws://" + location.hostname + "/test");
        websocket.onopen = function(evt) {
          onOpen(evt)
        };
        websocket.onclose = function(evt) {
          onClose(evt)
        };
        websocket.onmessage = function(evt) {
          onMessage(evt)
        };
        websocket.onerror = function(evt) {
          onError(evt)
        };
      }
    </script>
    <div id="customModal">
      <div>
        <p>Nenhuma imagem enviada. O que vocÃª deseja fazer?</p>
        <button onclick="onModalOk()">OK</button>
        <button onclick="onModalClear()">Limpar tela</button>
      </div>
    </div>
  </body>
</html>
